/**
 * Предоставляет возможность создавать потоки (Threads), позволяющие параллельное выполнение нескольких методов.
 *
 * Предоставляет возможность создавать потоки (Threads), позволяющие параллельное выполнение нескольких методов.<br/>
 * Для создания потока, необходимо создать класс, определяеющий метод интерфейса Runnable.run().
 * Тело этого метода и будет являться кодом для исполнения потока.<br/>
 * Например:<br/>
 * class my_thread implements Runnable<br/>
 * {<br/>
 * &nbsp;&nbsp;void run()<br/>
 * &nbsp;&nbsp;{<br/>
 * &nbsp;&nbsp;&nbsp;&nbsp;for (int i=0; i<10; i++)<br/>
 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ System.print("This is thread\n"); Thread.sleep(500); }<br/>
 * &nbsp;&nbsp;}<br/>
 * }<br/>
 * Для запуска метода my_thread.run() в отдельном потоке, необходимо создать поток и запустить его:<br/>
 * Thread thr=new Thread(new my_thread(), "my_thread");<br/>
 * thr.start();<br/>
 * thr.join();<br/>
 * Код выше создает отдельный поток (new Thread()), запускает его (Thread.start()) для выполнения метода my_thread.run() и дожидается его завершения (Thread.join()).
 */
class Thread
{
    /**
     * private
     *
     * Имя нитки
     */
    String name;
    
    /**
     * private
     *
     * Код нитки
     */
    Runnable thr;
    
    /**
     * private
     *
     * Блокировка, что нитка работает
     */
    Object running=new Object();
    
    
    /**
     * Создает новый поток исполнения
     *
     * Создает новый поток исполнения. Запуска потока при этом не происходит.
     *
     * @param thr класс, определяющий метод Runnable.run() для запуска в новом потоке
     * @param name строковое имя потока
     */
    constructor(Runnable thr, String name)
    {
	this.thr=thr;
	this.name=name;
    }
    
    
    /**
     * Запускает поток на выполнение. Вызывающий поток при этом не блокируется.
     */
    void start()
    {
	if (__fork(name.getBytes()))
	{
	    // Ставим блок, что нитка работает
	    IPC.lock(running);
	    
	    // Выполняем код нитки
	    thr.run();
	    
	    // Снимаем блок - нитка остановлена
	    IPC.unlock(running);
	} else
	{
	    // Ждем запуска ребенка
	    while (IPC.tryLock(running))
	    {
		IPC.unlock(running);
		Thread.sleep(1);
	    }
	}
    }
    
    
    /**
     * Проверяет, работает ли еще поток
     *
     * @return true, если поток все еще выполняется, или false - в случае, если поток завершил свое исполнение (произошел выход из метода Runnable.run())
     */
    boolean isRunning()
    {
	if (IPC.tryLock(running))
	{
	    // Не работает
	    IPC.unlock(running);
	    return false;
	} else
	{
	    // Работает
	    return true;
	}
    }
    
    
    /**
     * Ожидает завершения выполнения потока. Выполняющий поток при этом блокируется до завершения указанного потока.
     */
    void join()
    {
	// Ждем завершения никти
	IPC.lock(running);
	IPC.unlock(running);
    }
    
    
    /**
     * Приостанавливает выполнение вызывающего потока на заданное количество миллисекунд
     *
     * @param ms время, на которое требуется приостановить выполнение вызывающего потока
     */
    native static void sleep(int ms);
    
    
    /**
     * Передает управление с вызывающего потока на следующий поток в очереди.
     * Используется, если задержка в 1мс слишком велика.
     */
    native static void yield();
    
    
    /**
     * private
     *
     * Возвращает true в новосозданной нитке
     */
    native byte __fork(byte[] name);
}
