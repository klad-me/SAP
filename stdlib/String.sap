/**
 * Позволяет хранить строку, состоящую из 8-битных символов. Также, описывает базовые операции над строками.
 *
 * Позволяет хранить строку, состоящую из 8-битных символов. Также, описывает базовые операции над строками.<br/>
 * Объект String можно создать двумя способами: обычным для классов и автоматическим.<br/>
 * Обычное создание класса выглядит следующим образом:<br/>
 * String s=new String(new byte{0x41, 0x42, 0x43});	// создает строку "ABC"<br/>
 * Автоматическое создание класса выглядит следующим образом:<br/>
 * String s="ABC";<br/>
 * Оба приведенные выше примера генерируют один и тот же код.
 */
class String implements Compareable
{
    /**private**/
    byte[] stringData;
    
    
    /**
     * Создает строку из массива байт.
     *
     * Создает строку из массива байт.
     * При этом, запоминается именно указатель, а не сама строка, т.е. при изменении массива-параметра, изменится и строка.
     *
     * @param data массив байт, представляющий символы строки
     */
    native constructor(byte[] data);
    
    
    /**
     * Возвращает размер строки в символах
     *
     * @return размер строки в символах
     */
    native int length();
    
    
    /**
     * Возвращает символ, содержащийся в строке на позиции idx
     *
     * @param idx позиция
     * @return символ, содержащийся в строке на указанной позиции
     */
    native byte charAt(int idx);
    
    
    /**
     * Возвращает массив байт, содержащий все символы строки
     *
     * @return массив байт, содержащий все символы строки
     */
    native byte[] getBytes();
    
    
    /**
     * Возвращает массив байт, содержащий Unicode представление строки
     *
     * Возвращает массив байт, содержащий Unicode представление строки.
     * При кодировании используется кодировка CP1251.
     *
     * @return массив, содержащий Unicode представление строки
     */
    native short[] toUnicode();
    
    
    /**
     * Создает строку из массива, содержащего Unicode представление строки
     *
     * Создает строку из массива, содержащего Unicode представление строки. Разбор начинается с позиции offs, разбирается size байт.
     * Также, разбор прекращается при обнаружении символа с кодом 0.
     * При раскодировании используется кодировка CP1251.
     *
     * @param data массив байт, содержащий Unicode представление строки
     * @param offs смещение, относительно начала массиа, где начинается текст
     * @param size размер данных
     * @return раскодированная строка
     */
    native static String fromUnicode(short[] data, int offs, int size);
    
    
    /**
     * Возвращает массив байт, содержащий UTF8 представление строки
     *
     * Возвращает массив байт, содержащий UTF8 представление строки.
     * Размер массива UTF8 может быть больше, чем количество символов в строке, т.к. UTF8 может генерировать более 1 байта на один символ.
     * При кодировании используется кодировка CP1251.
     *
     * @return массив байт, содержащий UTF8 представление строки
     */
    native byte[] toUTF8();
    
    
    /**
     * Создает строку из массива байт, содержащего UTF8 представление строки
     *
     * Создает строку из массива байт, содержащего UTF8 представление строки. Разбор UTF8 начинается с позиции offs, разбирается size байт.
     * Также, разбор прекращается при обнаружении символа с кодом 0 или неверной последовательности байт UTF8.
     * При раскодировании используется кодировка CP1251.
     *
     * @param data массив байт, содержащий UTF8 представление строки
     * @param offs смещение, относительно начала массиа, где начинается UTF8
     * @param size размер данных UTF8 в байтах
     * @return раскодированная строка
     */
    native static String fromUTF8(byte[] data, int offs, int size);
    
    
    /**
     * Сравнивает хранимую строку и строку, представленную объектом o
     *
     * @param o объект для сравнения
     * @return true, если строки одинаковые или false - в остальных случаях
     */
    native boolean equals(Object o);
    
    
    /**
     * Сравнивает хранимую строку и параметр. Сравнение производится по кодам символов.
     * При этом, короткая строка считается меньше длинной ("abc" < "abcd").
     *
     * @param s строка для сравнения
     * @return 0 в случае, если строки равны, <0 в случае, если хранимая строка стоит раньше параметра, >0 в случае, если хранимая стока стоит после параметра
     */
    native int compareTo(String s);
    
    
    /**
     * Определяет позицию символа <b>c</b> в строке
     *
     * @param c искомый символ
     * @return позиция первого найденного символа или -1 в случае, если символ не найден
     */
    native int indexOf(byte c);
    
    
    /**
     * Определяет, начинается ли строка с указанной подстроки
     *
     * @param str строка для поиска
     * @return true, если строка начинается с указанной подстроки, или false - в ином случае
     */
    native boolean startsWith(String str);
    
    
    /**
     * Определяет, заканчивается ли строка указанной подстрокой
     *
     * @param str строка для поиска
     * @return true, если строка заканчивается указанной подстрокой, или false - в ином случае
     */
    native boolean endsWith(String str);
    
    
    /**
     * Возвращает строку, содержащую указанную часть хранимой строки (подстроку)
     *
     * @param begin начальный символ (войдет в подстроку)
     * @param end конечный символ (не войдет в подстроку)
     * @return подстрока, состоящая из символов хранимой строки с индексами от begin до end
     */
    native String substring(int begin, int end);
    
    
    /**
     * Добавляет к хранимой строке в конец другую строку
     *
     * Добавляет к хранимой строке в конец другую строку.<br/>
     * Например: "ABC".append("XYZ") получит в результате строку "ABCXYZ"
     *
     * @param str строка для добавления
     * @return новая строка
     */
    native String append(String str);
    
    
    /**
     * Преобразует хранимую строку к нижнему регистру.
     * При преобразовании используется кодировка CP1251.
     *
     * @return строка в нижнем регистре
     */
    native String toLowerCase();
    
    
    /**
     * Преобразует хранимую строку к верхнему регистру.
     * При преобразовании используется кодировка CP1251.
     *
     * @return строка в верхнем регистре
     */
    native String toUpperCase();
    
    
    /**
     * Обрабатывает "аргумент" в строке
     *
     * Обрабатывает очередной аргумент в строке.
     * "Аргумент" представляет из себя последовательность символов "%x", где x - любая цифра или буква (регистрозависимая).
     * При вызове метода String.arg() ищется наименьший номер "аргумента" (используя при сравнении код символа) и заменяется на значение
     * аргумента.<br/>
     * Например: "Привет, %1 ! У тебя %2 сообщений.".arg("пользователь").arg("10") получится строка: "Привет, пользователь ! У тебя 10 сообщений."
     *
     * @param value значение "аргумента"
     * @return преобразованная строка
     */
    String arg(String value)
    {
	// Ищем по строке минимальный индекс
	byte min=127;
	int idx=-1;
	int l=0;
	
	for (int i=0; i<stringData.length; i++)
	{
	    if ( (stringData[i]=='%') && (i<stringData.length-1) )
	    {
		byte c=stringData[i+1];
		if (c=='%')
		{
		    // Надо уменьшить строку на 1
		    l--;
		    i++;
		} else
		if ( (c!='%') && (c<min) )
		{
		    min=c;
		    idx=i;
		}
	    }
	}

	// Получаем длину новой строки
	l=l+stringData.length;
	if (idx>=0) l=l+value.length()-2;
	
	// Создаем новую строку
	byte[] str=new byte[l];
	if (str==null) return this;
	
	int n=0;
	for (int i=0; i<stringData.length; i++)
	{
	    if (i==idx)
	    {
		// Сюда надо вставить нашу строку
		System.arrayCopy(value.getBytes(), 0, str, n, value.length());
		i++;
		n=n+value.length();
	    } else
	    {
		// Это просто символ
		if ( (stringData[i]=='%') && (i<stringData.length-1) )
		{
		    byte c=stringData[i+1];
		    if (c=='%')
		    {
			str[n++]='%';
			i++;
			continue;
		    }
		}
		str[n++]=stringData[i];
	    }
	}
	
	return new String(str);
    }
    
    
    /**
     * Удаляет пробелы вначале и вконце строки
     *
     * @return строку без пробелов в начале и конце строки
     */
    String trim()
    {
	// Считаем сначала длину строки без завершающих пробелов
	int l=stringData.length;
	for ( ; (l>0) && (stringData[l-1]==' '); l--);
	
	// Считаем кол-во пробелов в начале и правим длину строки
	int leading=0;
	for ( ; (l>0) && (stringData[leading]==' '); leading++, l--);
	
	// Создаем новую строку
	byte[] s=new byte[l];
	if (s==null) return null;
	System.arrayCopy(stringData, leading, s, 0, l);
	
	return new String(s);
    }
}
