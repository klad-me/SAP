/**
 * Класс DataStream представляет из себя оболочку над интерфейсом Stream.
 * Данный класс позволяем использовать данные с приведением к конкретному типу
 * (в отличии от интерфейса Stream, который оперирует лишь потоками байт).
 */
class DataStream
{
    /**
     * private
     *
     * Поток, из которого берутся и записываются данные
     */
    Stream s;
    
    /**private**/
    byte[] tmp=new byte[4];
    
    
    /**
     * Создает объект DataStream из указанного потока.
     *
     * @param s поток для входных/выходных данных
     */
    constructor (Stream s)
    {
	this.s=s;
    }
    
    
    /**
     * Прочитать байт из потока
     *
     * @return прочитанное значение, или 0 в случае неудачи
     */
    byte readByte()
    {
	if (s.readBytes(tmp, 0, 1)!=1) return 0;
	return tmp[0];
    }
    
    
    /**
     * Прочитать short (2 байта) из потока
     *
     * @return прочитанное значение, или 0 в случае неудачи
     */
    short readShort()
    {
	if (s.readBytes(tmp, 0, 2)!=2) return 0;
	return (short)( (tmp[1] << 8) | ((int)tmp[0] & 0xff) );
    }
    
    
    /**
     * Прочитать int (4 байта) из потока
     *
     * @return прочитанное значение, или 0 в случае неудачи
     */
    int readInt()
    {
	if (s.readBytes(tmp, 0, 4)!=4) return 0;
	return
	    (((int)tmp[3] & 0xff) << 24) |
	    (((int)tmp[2] & 0xff) << 16) |
	    (((int)tmp[1] & 0xff) << 8) |
	    (((int)tmp[0] & 0xff)) ;
    }
    
    
    /**
     * Прочитать float (4 байта) из потока
     *
     * @return прочитанное значение, или 0.0 в случае неудачи
     */
    float readFloat()
    {
	return Float.intBitsToFloat(readInt());
    }
    
    
    /**
     * Прочитать строку из потока. Сначала читается длина (2 байта), потом 8-битные символы
     *
     * @return прочитанная строка или null в случае ошибки
     */
    String readString()
    {
	int l=readShort();
	byte[] data=new byte[l];
	if (data==null) return null;	// странная строка
	s.readBytes(data, 0, l);
	return new String(data);
    }
    
    
    /**
     * Записать байт в поток
     *
     * @param v значение для записи
     */
    void writeByte(byte v)
    {
	tmp[0]=v;
	s.writeBytes(tmp, 0, 1);
    }
    
    
    /**
     * Записать short (2 байта) в поток
     *
     * @param v значение для записи
     */
    void writeShort(short v)
    {
	tmp[0]=(byte)v;
	tmp[1]=(byte)(v >> 8);
	s.writeBytes(tmp, 0, 2);
    }
    
    
    /**
     * Записать int (4 байта) в поток
     *
     * @param v значение для записи
     */
    void writeInt(int v)
    {
	tmp[0]=(byte)v;
	tmp[1]=(byte)(v >> 8);
	tmp[2]=(byte)(v >> 16);
	tmp[3]=(byte)(v >> 24);
	s.writeBytes(tmp, 0, 4);
    }
    
    
    /**
     * Записать float (4 байта) в поток
     *
     * @param v значение для записи
     */
    void writeFloat(float v)
    {
	writeInt( Float.floatToIntBits(v) );
    }
    
    
    /**
     * Записать строку в поток. Сначала записывается длина (2 байта), после 8-битные символы
     *
     * @param str строка для записи
     */
    void writeString(String str)
    {
	if (str==null)
	{
	    // Пустая строка
	    writeShort(0);
	} else
	{
	    byte[] data=str.getBytes();
	    writeShort((short)data.length);
	    s.writeBytes(data, 0, data.length);
	}
    }
    
    
    /**
     * Записать строку в поток.
     *
     * Записывает строку в поток.
     * Запись производится в 8-битном формате в кодировке, используемой в языке. Обычно это cp1251.
     * Никакие данные о размере или завершающий символ не записываются.
     *
     * @param str строка для записи
     */
    void print(String str)
    {
	s.writeBytes(str.getBytes(), 0, str.length());
    }
}
