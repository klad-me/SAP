<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=koi8-r" />
  <title>Язык SAP</title>
</head>
<body>
<font size="+2"><b>Язык программирования SAP. Руководство программиста.</b></font><br/>
<br/>
<font size="+1"><b>Содержание</b></font>
<ul>
    <li><a href="#vvedenie">1. Введение</a></li>
    <li><a href="#sredstva_razrabotki">2. Средства разработки</a></li>
    <li><a href="#hello_world">3. Программа Hello World</a></li>
    <li><a href="#yazyk">4. Краткое описание языка</a></li>
    <li><a href="#stdlib">5. Стандартные классы</a></li>
    <li><a href="#contacts">6. Контакты с разработчиком</a></li>
</ul>
<br/>
<br/>


<!-- -------------------------------------------------------- -->
<br/>
<a name="vvedenie"/>
<font size="+1"><b>1. Введение</b></font>

<p><b>Что требуется знать перед тем, как читать это руководство</b></p>
<p>Перед тем, как приступить к чтению данного руководства, необходимо иметь 
навыки программирования на языке Си или Java.
Также, обязательно понимать и уметь использовать объектно-ориентированное 
программирование, желательно программировать на каком-либо объектом языке. 
Очень рекомендуется ознакомиться с языком программирования Java, т.к. 
язык SAP основан на Java.</p>


<p><b>Причины создания нового языка программирования</b></p>
<p>На сегодняшний день, в промышленной автоматике чаще всего используются 
программируемые микроконтроллеры с очень ограниченными ресурсами. 
Новичек в программировании контроллеров сразу сталкивается с тем, что приходится 
работать с процессором, объем ОЗУ которого ограничен несколькими килобайтами. 
Вначале, это кажется дикостью, т.к. порой нам не хватает и гигабайта ОЗУ на 
нашем компьютере.
Однако первое впечатление обманчиво. Сама программа обычно исполняется 
непосредственно с Flash-памяти контроллера, а ОЗУ используется лишь для 
хранения обрабатываемых данных. Это различается с архитектурой персонального 
компьютера, где программа с жесткого диска сначала загружается для исполнения 
в ОЗУ. В любом случае, единицы килобайт оперативной памяти не дают возможности 
использовать для программирования что-либо, кроме языка Си, т.к. он является 
достаточно низкоуровневым и позволяет вести контроль за потребляемыми ресурсами.
Однако, программы на языке Си достаточно сложно отлаживать, особенно, если 
микропроцессор не имеет возможности внутрисхемной отладки. О системе обоработки 
ошибок и говорить нечего. Одно неверное действие и микпропроцессор зависнет 
или заглючит - такая вот плата за низкоуровневость языка. Об использовании 
какого-либо другого языка, компилируемого в код процессора (например Pascal) 
можно забыть, т.к. производители микропроцессоров обычно предоставляют довольно 
скудный набор средств разработки, часто заканчивающийся на компиляторе языка Си.</p>

<p>Каким же образом можно изменить ситуацию ? Остается, пожалуй, один выход - 
виртуальная машина. Виртуальная машина - это фактически вымышленный процессор 
со своей архитектурой и системой команд. Программы для виртуальной машины также 
компилируются из исходных текстов (это может быть даже Си), а выполняются на 
исполнительной системе - т.е. программе, которая исполняет придуманный машинный 
код. Самые известные виртуальные машины (и языки программирования) - это Java и 
.NET (язык C#). Java при этом отличается тем, что стандарт на язык и виртуальную 
машину открыт. Также доступно большое количество компиляторов и виртаульных машин 
для Java. Однако, даже мобильная Java (J2ME на мобильных устройствах) рассчитана 
на устройства с сотнями килобайт оперативной памяти и довольно мощным процессором. 
Не каждый контроллер для промышленной автоматики готов похвастаться такой переферией. 
Всеже 90% выпускаемых контроллеров промышленной автоматики имеют в среднем 
128-512 кб Flash-памяти для хранения программы и 8-64 кб ОЗУ. При таком малом объеме 
ОЗУ, Java-программа смогла бы работать, если бы не одно "НО" - архитектура 
сборщика мусора. Java, как известно, - это язык с автоматической сборкой мусора, 
т.е. объект создается по необходимости и удаляется только тогда, когда он больше 
не нужен (когда ни одна переменная на этот объект не ссылается). В языке Java 
алгоритм сборки мусора основан на периодическом (но не очень частом) процессе 
сборки мусора. Сам процесс сборки мусора - довольно долгая процедура, т.к. 
необходимо для каждого существующего объекта подсчитать количество ссылок на него из
переменных, используемых в программе. Обычно данная процедура запускается либо 
пользователем в момент, когда процессор свободен, или принудительно виртуальной 
машиной, когда заканчивается свободная память. В случае с небольшим количеством 
ОЗУ, сборщик мусора будет запускаться довольно часто, что сильно снизит 
производительность исполнительной системы. К сожалению, изменить систему сборки 
мусора в языке Java невозможно, т.к. этого не предполагает генерируемый байт-код.</p>

<p>Остается единственный выход - разработать собственный язык программирования, 
компилятор которого будет генерировать байт-код, помогающий сборке мусора. 
За основу был взят язык Java. Было решено отказаться от типов long, double, 
исключений и флагов доступа (и некоторых других незначительных вещей).
Был разработан байткод, позволяющий удалять объект сразу же, как только на него 
не будет ссылаться ни одна переменная. Таким образом, в каждый момент работы 
программы, в памяти находятся только используемые объекты !</p>

<p>Появился язык и платформа SAP. Название SAP - это аббревиатура от 
"Small Application Platform" (платформа для небольших приложений). Была создана 
легко портируемая исполнительная система, благодаря тому, что она написана на 
языке Си без использования платформо-зависимых частей.</p>



<!-- -------------------------------------------------------- -->
<br/>
<a name="sredstva_razrabotki"/>
<font size="+1"><b>2. Средства разработки</b></font>

<p><b>Командная строка или IDE</b></p>
<p>Средства разработки для языка SAP изначально созданы под использования 
в командной строке, однако это не мешает использования IDE. Компилятор SAP 
легко встраивается в практически любой IDE. При настройке подсветки синтаксиса 
и подсказок, следует установить режим работы с языком Java.</p>


<p><b>Доступные средства</b></p>
<p>Для языка SAP предоставляется компилятор и линковщик, объединенные в одной 
программе, называемой <b>sapc</b> (SAP Compiler). Также, при покупке контроллера, 
на диске может быть программа-симулятор работы контроллера. Симулятор позволяет 
запускать программу для контроллера на персональном компьютере. Это значительно 
облегчает и ускоряет процесс отладки программного обеспечения.</p>


<p><b>Параметры запуска компилятора</b></p>
<p>Для вывода справки по параметрам запуска компилятора, можно просто запустить 
программу <b>sapc</b> без параметров.</p>

<p>Параметры запуска компилятора состоят из опций и имен исходных файлов. 
Опции начинаются со знака '-', за которым следует название опции. После опции
может следовать параметр. В командной строке можно указать несколько опций и 
исходных файлов, причем порядок не имеет значения. Обычно, компилятор используют 
для компиляции одного файла, однако есть момент, при котором требуется указание 
нескольких файлов. Такой момент - это перекрестная зависимость двух классов, 
находящихся в разных файлах (только в случае, если оба класса еще не 
откомпилированы). Вообще, рекомендуется указывать сразу все исходные тексты 
проекта, чтобы искплючить ошибок отлова зависимостей.</p>

<p>Доступные опции:<br/>
"-i &lt;каталог&gt;" - указать каталог, где искать библиотеки (объектные файлы), 
можно указать сколько угодно каталогов<br/> 
"-o &lt;каталог&gt;" - указать каталог, куда записывать откомпилированные 
объекты, можно указать только один каталог<br/>
"-l &lt;класс&gt;" - линковать программу с указанием запускаемого класса, 
можно указать только один раз<br/>
"-debug" - включить отладочный вывод компилятора (для сообщения разработчику
компилятора об ошибке компиляции)<br/>
"-asm" - включить вывод ассемблерного кода при компиляции (только при включенной
опции -debug)<br/>
</p>

<p>Исходные тексты обычно помещаются в файлы с расширением '.sap'. Никаких 
ограничений на имя не накладывается. В любом файле можно хранить
исходный код любых классов. После компиляции исходных текстов, получаются 
объектные модули с расширением '.sapclass', которые позже линкуются в 
исполняемый файл. После линковки (опция -l), из нескольких объектных файлов 
(которые реально используются в проекте) получается исполняемый файл с 
расширением '.sapexe'. Имя дается по имени главного запускаемого класса.</p>



<!-- -------------------------------------------------------- -->
<br/>
<a name="hello_world"/>
<font size="+1"><b>3. Программа Hello World</b></font>

<p><b>Ниже приведен текст программы Hello World:</b></p>
<pre><code>
class HelloWorld
{
    static void main()
    {
	System.print("Hello world\n");
    }
}
</code></pre>

<p>Приведенная выше программа выводит на экран строку "Hello World". 
Для компиляции и запуска, необходимо сохранить исходный код в файл, например
HelloWorld.sap, и выполнить следующие действия:<br/>
sapc HelloWorld.sap<br/>
sapc -l HelloWorld<br/>
Появится исполняемый файл HelloWorld.sapexe, который можно запустить в симуляторе:<br/>
sapvm HelloWorld.sapexe<br/>
Программа выведет на экран сообщение "Hello World" и завершится.</p>

<p>Каждая программа, написанная на языке SAP должна запускаться с определенной 
точки входа. За точку входа был выбран статический метод main(). Определив в 
любом классе метод <b>static void main()</b> (обязательно именно такое объявление), 
этот класс становится доступным для запуска, и именно имя этого класса передается 
линковщику после ключа '-l'.</p>

<p>Как видно из примера, описание класса и метода вполне стандартно для языка Java. 
Метод System.print аналогичен методу System.out.print из Java.</p>



<!-- -------------------------------------------------------- -->
<br/>
<a name="yazyk"/>
<font size="+1"><b>4. Краткое описание языка</b></font>

<p><b>Состав программы</b></p>
<p>Программа состоит из одного или более классов и интерфейсов. Интерфейс, в
отличии от класса, не реализует методов и не определяет полей. Задача интерфейса -
описать программный интерфейс к чему-либо. Фактически, перечисляются методы, которые
должен определить класс для соответствия интерфейсу.</p>
<p>Класс описывает поля (переменные) и методы (функции). У класса может быть только
один класс-предок. Класс может определять любое количество интерфейсов. Экземпляр
класса можно привести к классу любого предка или к любому определенному интерфейсу.
Также, следует заметить, что потомком всех классов является специальный класс Object.
К этому классу можно приводить экземпляры любых классов, а также любые массивы.</p>


<p><b>Кодировка исходника</b></p>
<p>Компилятор языка SAP пытается автоматически определить кодировку исходника по
содержимому файла. Поддерживаются кодировки Windows (Cp1251), DOS (Cp866) и Unix (KOI8-R).
Перед компиляцией исходник перекодируется в кодировку Windows (принятую за стандартную в
языке SAP).<br/>
В случае, если компилятор неверно определяет кодировку (хотя я ни разу не видел такого),
возможно указать кодировку вручную. Для этого, первым словом в файле (не считая комментариев)
должна идти команда указания кодировки: "WIN" - для Windows, "DOS" - для DOS, "KOI" для
KOI8-R.
</p>


<p><b>Описание класса</b></p>
<p>Класс может быть описан в любом файле. Класс является элементом верхнего уровня, 
поэтому недопускается описание класса внутри любой языковой конструкции. В описании 
класса указывается родитель (если есть) и список реализуемых интерфейсов. 
В теле класса описываются поля и методы в произвольном порядке. Ниже приведена 
общая форма определения класса</p>
<pre><code>
class &lt;name&gt; [extends &lt;name&gt;] [implements &lt;name1&gt;[, &lt;name2&gt; ....]]
{
    &lt;fields&gt;
    &lt;methods&gt;
}
</code></pre>
</p>

<p><b>Описание интерфейса</b></p>
<p>Интерфейс, как и класc может быть описан в любом файле на верхнем уровне. 
Интерфейс представляет собой список заголовков методов, которые класс обязательно 
должен определить. Экземпляр класса позже можно будет привести к интерфейсу и 
использовать описанные методы. Иными словами, инетрфейс это что-то типа 
множественного наследования в языке Си++ или указателей на функции в языке Си. 
Ниже представлена общая форма определения интерфейса:</p>
<pre><code>
interface &lt;name&gt;
{
    &lt;methods_headers&gt;
}
</code></pre>

<br/>
<p><b>Пример использования интерфейса</b></p>
<pre><code>
interface Number
{
    int intValue();
}
class Byte implements Number
{
    byte value;
    int intValue() { return value; }
}
class Short implements Number
{
    short value;
    int intValue() { return value; }
}
...
...
boolean compareNumbers(Number o1, Number o2)
{
    return o1.intValue() == o2.intValue();
}
</code></pre>


<p><b>Описание полей класса</b></p>
<p>Класс может иметь любое количество полей. Поле - это фактически локальная
переменная для каждого экземпляра данного класса. Поля могут быть статическими,
т.е. доступны вне контекста определенного экземпляра класса. Для доступа к
статическому полю доступен дополнительный метод: <code>classname.field</code>.
Также, поле может быть финальным (константным), т.е. изменение значение данного
поля не допускается во время выполнения программы.<br/>
Общая форма описания полей выглядит следующим образом:
<pre><code>
class classname
{
    [static] [final] &lt;type&gt; field_name[=&lt;expression&gt;], ....;
}
</code></pre>
Следует заметить, что имя поля должно быть уникальным в контексте данного класса,
а также не пересекаться с полями классов-родителей.<br/>
</p>


<p><b>Описание конструктора класса</b></p>
<p>Конструктор класса - это специальный метод, который вызывается при создании
нового экземпляра класса вызовом команды <b>new</b>. Язык SAP не поддерживает
перегрузку конструкторов, т.е. у класса может быть только один конструктор с
определенными параметрами вызова.<br/>
Конструктор не имеет возвращаемого типа (т.к. оператор new всегда возвращает
экземпляр созданного класса).<br/>
Конструктор описывается одним из следующих способов:<br/>
<pre><code>
class classname
{
    constructor(params...) [ : super(params...) ]
    {
    }
}

или

class classname
{
    classname(params...) [ : super(params...) ]
    {
    }
}
</code></pre>
Первая форма записи будет привычна тем, кто пишет на C++ или Java. Однако, по-моему мнению,
конструкция constructor(...) удобнее в плане легкости визуального поиска конструктора
в теле класса, а также независимость от имени класса (в случае необходимости
переименовать класс).<br/>
При необходимости, можно указать параметры вызова конструктора предка (super).
</p>


<p><b>Описание метода класса</b></p>
<p>
Класс может содержать любое количество методов. Язык SAP не поддерживает перегрузку методов,
поэтому имя метода должно быть уникально в контексте одного класса, а также классов-родителей.
Класс, реализующий интерфейсы, должен реализовать все методы всех объявленных интерфейсов.
Следует заметить, что имена полей и имена методов могут пересекаться.<br/>
Метод класса описывается следующим образом:
<pre><code>
class classname
{
    [static] &lt;type&gt; methodname([&lt;type&gt; paramname, ....])
    {
	...
    }
    
    [static] void methodname([&lt;type&gt; paramname, ....])
    {
	...
    }
}
</code></pre>
Метод может не иметь параметро вызова, в таком случае он записывается как methodname(). Метод, также
может не иметь возвращаемого значения, в таком случае тип возвращаемого значения записывается как void.<br/>
При указании слова <b>static</b>, метод становится статическим, т.е. его вызов доступен вне контекста
экземпляра класса. Это накладывает одно ограничение: статический метод не может использовать
не-статические поля и методы собственного класса без указания экземпляра класса.<br/>
Существует также флаг метода <b>native</b>. Данный флаг указывает, что данный метод будет
реализован не на языке SAP, а на языке Си на уровне виртуальной машины. При указании флага native,
вместо кода метода ({...}) ставится просто точка с запятой ';'.
</p>


<p><b>Типы данных</b></p>
<p>
В языке SAP типы делятся на три вида:
<ul>
    <li>примитивные типы</li>
    <li>экземпляры классов (объекты)</li>
    <li>массивы</li>
</ul>
Примитивными типами являются:
<ul>
    <li>byte - 8-бит знаковый</li>
    <li>short - 16-бит знаковый</li>
    <li>int - 32-бит знаковый</li>
    <li>float - 32-бит вещественный</li>
</ul>
Следует заметить, что в отличии от Java, в языке SAP нет типа boolean. Однако, при
компиляции тип boolean считается за тип byte, а символы true и false интерпретируются за
значения 1 и 0 соответственно. При этом, в условных операторах, где требуется
булевское значение, необходим любой целочисленный тип результата (byte, short, int).
Нулевое значение считается за "ложь", ненулевое за "правду".<br/>
<br/>
Тип, описывающий экземпляр класса (объект) состоит просто из названия класса:
<pre><code>
classname varname;
</code></pre>
<br/>
Описание типа-массива немного отличается от описания в языках Си и Java. Отличие в том,
что в языке SAP тип-массив описывается полностью в типе, а в языках Си и Java описывается
базовый тип, а признак массива [] указывается после имени каждой переменной.
<pre><code>
SAP:
byte[] array;

C, Java:
byte array[];
</code></pre>
Многомерные массивы записываются как &lt;type&gt;[][]. Язык SAP поддерживает максимум
15-мерные массивы.<br/>
<br/>
Также, как и в языке Java, экземпляр любого класса или массив можно привести к типу Object
(в результате того, что класс Object является родителем любого класса).
</p>


<p><b>Область видимости переменной</b></p>
<p>
Область видимости переменной в языке SAP не отличается от языков Си и Java.
Видимость переменной ограничивается блоком кода, переопределение переменных
запрещено.
</p>


<p><b>Конструкции кода</b></p>
<p>
Ниже приведен перечень конструкций кода языка SAP:
<pre><code>
<b>Блок кода:</b>
{
    statements
}

<b>Пустой оператор (нет действия):</b>
;	// просто точка с запятой

<b>Условный оператор:</b>
if (expression) statement
if (expression) statement else statement

<b>Цикл while:</b>
while (expression) statement

<b>Цикл do-while:</b>
do statement while (expression);

<b>Цикл for:</b>
for (expression-list; expression; expression-list) statement

<b>Выход из цикла (break):</b>
break;
break N;	// N - уровень вложенности, break 1; аналогичен break;

<b>Продолжение цикла (continue):</b>
continue;
continue N;	// N - уровень вложенности, continue 1; аналогичен continue;

<b>Выход из метода:</b>
return;			// выход из void-метода
return expression;	// выход из метода с возвратом значения

<b>Определение метки:</b>
label:		// имя метки и символ двоеточия

<b>Безусловный переход:</b>
goto label;

<b>Оператор выбора:</b>
switch (expression)
{
    case expression:
	statement
	....
    
    case expression:
	....
    
    default:
	....
}

<b>Синхронизованный блок:</b>
synchronized (expression) statement	// блокировка объекта, блокированный объект не может быть заблокирован в другой нити

<b>Выражение:</b>
expression;	// выражение тоже является конструкцией кода
</code></pre>
</p>


<p><b>Выражения (expressions)</b></p>
<p>
Ниже приведен список поддерживаемых выражений:
<pre><code>
<b>Присваивание:</b>
expression = expression
expression *= expression
expression /= expression
expression %= expression
expression += expression
expression -= expression
expression &= expression
expression |= expression
expression ^= expression
expression &lt;&lt;= expression
expression &gt;&gt;= expression
expression &gt;&gt;&gt;= expression	// беззнаковый сдвиг вправо (как в Java)

<b>Условное выражение:</b>
expression ? expression : expression

<b>Логические выражения:</b>
expression || expression	// особенность выражения в том, что если первое выражение true, то второе не считается
expression && expression	// особенность выражения в том, что если первое выражение false, то второе не считается
! expression

<b>Битовые операции:</b>
expression | expression
expression & expression
expression ^ expression
expression &gt;&gt; expression
expression &gt;&gt;&gt; expression	// беззнаковый сдвиг вправо (как в Java)
expression &lt;&lt; expression
~ expression

<b>Выражения сравнения:</b>
expression == expression
expression != expression
expression &gt; expression
expression &lt; expression
expression &gt;= expression
expression &lt;= expression

<b>Математические выражения:</b>
expression + expression
expression - expression
expression * expression
expression / expression
expression % expression
- expression
expression ++
expression --
++ expression
-- expression

<b>Изменение приоритета выражения:</b>
( expression )

<b>Операции с типами:</b>
(type) expression		// приведение типа
expression instanceof type	// проверка типа

<b>Доступ к элементу массива:</b>
expression [ expression ]

<b>Доступ к полям класса:</b>
field
expression.field
classname.field		// только для статических полей

<b>Доступ к методам класса:</b>
method(...)
expression.method(...)
classname.method(...)	// только для статических методов

<b>Создание экземпляра класса (объекта):</b>
new classname(...)

<b>Создание массива:</b>
new type[expression]

<b>Создание массива с инициализацией:</b>
new type{expression, .....}

<b>Вызов метода предка:</b>
super.method(....)
</code></pre>
</p>




<!-- -------------------------------------------------------- -->
<br/>
<a name="stdlib"/>
<font size="+1"><b>5. Стандартные классы</b></font>

<p>Стандартные классы обычно находятся в каталоге stdlib. Набор классов различается
в зависимости от устройства, под которое сделана сборка виртуальной машины SAP.
В любом случае, документация на стандартные классы доступна в каталоге stdlib/doc.
Файл index.html содержит страницу с описаниями всех классов и удобной навигацией.
</p>





<!-- -------------------------------------------------------- -->
<br/>
<a name="contacts"/>
<font size="+1"><b>6. Контакты с разработчиком</b></font>

<p>Я всегда готов помочь в освоении и использовании языка SAP. Также, я готов
портировать виртуальную машину SAP на любой контроллер.<br/>
<br/>
Алексей Пресняков<br/>
<a href="mailto:me@klad.me">me@klad.me</a><br/>
<a href="http://klad.me">http://klad.me</a><br/>
+7-962-475-40-04 (с 10:00 до 20:00 МСК)<br/>
</p>

</body>
</html>
